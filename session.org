* Important details
  - 17:30 -- where to attach points-to set.
    : TUninitialized(DeclStmt ds, LocalVariable lv)
    uses the relation =TUninitialized= to /connect/ =lv= and =ds=.  The =DeclStmt=
    may still contain an initializer.

  - 18:33 -- why invalid.
    : TUninitialized
    or 
    : TVariableOutOfScope
    Together,
    #+BEGIN_SRC ocaml
      newtype TInvalidReason =
          TUninitialized(DeclStmt ds, LocalVariable lv) { ds.getADeclaration() = lv } or
          TVariableOutOfScope(LocalVariable lv, ControlFlowNode cfn) { goesOutOfScope(lv, cfn) }
    #+END_SRC

  - Can also point to unknown.

  - 22:47 top-down, first
    #+BEGIN_SRC ocaml
      newtype TPSetEntry =
          PSetVar(LocalVariable lv) or
          PSetInvalid(InvalidReason ir) or
          PSetUnknown()
    #+END_SRC
    then

  - 23:28
    #+BEGIN_SRC ocaml
      newtype TInvalidReason =
          TUninitialized(DeclStmt ds, LocalVariable lv) { ds.getADeclaration() = lv } or
          TVariableOutOfScope(LocalVariable lv, ControlFlowNode cfn) { goesOutOfScope(lv, cfn) }
    #+END_SRC
    - Vars are uninitialized at point of declaration; they're just space on the
      stack.  The =DeclStmt= may still contain an initializer, but that's a later
      operation.

    - The body of
      : TUninitialized(DeclStmt ds, LocalVariable lv) { ds.getADeclaration() = lv }
      is needed to avoid huge cartesian products.  The relation =TUninitialized=
      only /connects/ (relates) =lv= and =ds=.  No deeper meaning is implied here.

    - As always in CodeQL, =TUninitialized= is a /set/ of /all values/ satisfying
      a property.

    - 26:11 New types are evaluated before any other parts of a query.  If they
      produce large sets, evaluation may be very slow.

* Dangling pointers
  :PROPERTIES:
  :CUSTOM_ID: dangling-pointers
  :END:
  A dangling pointer is a memory safety violation where the pointer does
  not point to a valid object. These dangling pointers are the result of
  not modifying the value of the pointer after the pointed to object is
  destructed or not properly initializing the pointer.

  The use of a dangling pointer can result in a security issue.
  Specifically in C++ if the pointer is used to invoke a /virtual/ method
  and an attacker was able to overwrite the parts of the memory that would
  have contained the =vtable= of the object.

  The following snippet shows how a dangling pointer can occur.

  #+begin_src cpp
    void dangling_pointer() {
        char **p = nullptr;
        {
            char * s = "hello world";
            p = &s;
        }
        printf("%s", *p);
    }
  #+end_src

  A less obvious case is

  #+begin_src cpp
    void dangling_pointer() {
        std::string_view s = "hello world"s;
        std::cout << s << std::endl;
    }
  #+end_src

  After the full expression is evaluated, the temporary object is
  destroyed.

  Many more interesting examples discussed here
  https://herbsutter.com/2018/09/20/lifetime-profile-v1-0-posted/

  To find these issues we can implement an analysis that tracks lifetimes.
  A nice specification for a local lifetime analysis is given by
  https://github.com/isocpp/CppCoreGuidelines/blob/master/docs/Lifetime.pdf

  The gist of the analysis is to track for each local variable the things
  it can point to at a particular location in the program. These are other
  local variables and special values for global variables, null values,
  and invalid values. Whenever a variable goes out of scope, each
  reference to that variable in a points-to set is invalidated.

  In the next few exercises, we are going to implement a simplified
  version of the lifetime profile to find the dangling pointer in the
  following example:

  #+begin_src cpp
    extern void printf(char *, ...);

    void simple_dangling_pointer() {
        char **p;
        {
            char *s = "hello world!";
            p = &s;
        }
        printf("%s", *p);
        char *s = "hello world!";
        p = &s;
        printf("%s", *p);
        return;
    }
  #+end_src

** Algebraic data types
   ADTs give us dynamic typing, just like unions in C:
   #+BEGIN_SRC c++
     typedef enum {
         TUninitialized = 0,
         TVariableOutOfScope
     } TInvCase;

     typedef struct {
         TInvCase the_case;
         union {
             DeclStmt ds;
             LocalVariable lv;
         };
     } TInvalidReason;
   #+END_SRC

   An algebraic datatype consists of a number of mutually disjoint branches;
   the algebraic datatype itself is the union of all the branch types.

   Simple ADT:
   #+BEGIN_SRC ocaml
     newtype TNum =
         TFloat(float) or
         TInt(int)
   #+END_SRC


** Summary
   The simplified version of the lifetime profile will track 3 possible /points-to/
   values, with one of two values in one case:

   1. Variable; A pointer points to another pointer. We will only consider
      local variables represented by the class =LocalVariable=.
   2. Invalid; A pointer
      1. is not initialized or
      2. points to a variable that went out of scope.
   3. Unknown; A pointer is assigned something other than the address of
      another =LocalVariable= (e.g., the address of a string.).

   In the following, we implement 2 ADTs in bottom-up order.  First, the invalid
   cases (#2), then the 3-case /points-to/ ADT.

** Exercise 1.0
   Define the uninitialized case
   : TUninitialized(DeclStmt ds, LocalVariable lv)
   as part of
   : newtype TInvalidReason 
   This uses the relation =TUninitialized= to /connect/ =lv= and =ds=.  The =DeclStmt=
   may still contain an initializer, but that's not relevant here; the initializer
   always runs /after/ the stack allocation.
   
*** Hints
    Find the =DeclStmt= s for all =LocalVariable= s.
*** Solution
    #+INCLUDE: "./src/solutions/Example10.ql" src java
*** First 5 results
    #+INCLUDE: "./tests/solutions/Example10/Example10.expected" :lines "-6"’


** Exercise 2.0
   Define the out-of-scope case
   :  TVariableOutOfScope(LocalVariable lv, ControlFlowNode cfn) { }
   as part of
   : newtype TInvalidReason 
   
*** Hints

*** Solution
    #+INCLUDE: "./src/solutions/Example20.ql" src java

*** First 5 results
    #+INCLUDE: "./tests/solutions/Example20/Example20.expected" :lines "-6"’


** Exercise 3.0
   Define a class =InvalidReason= to handle the printing of the =TInvalidReason=
   ADT.

*** Solution
    #+INCLUDE: "./src/solutions/Example30.ql" src java

*** First 5 results
    #+INCLUDE: "./tests/solutions/Example30/Example30.expected" :lines "-6"’


** Exercise 4.0
*** ADT
   Define an ADT
   : newtype TPSetEntry =...
   to handle the outer cases, using the names indicated
   in the following:

   1. Variable; A pointer points to another pointer. We will only consider
      local variables represented by the class =LocalVariable=.
      Use 
      : PSetVar(LocalVariable lv) or
   2. Invalid; A pointer
      1. is not initialized or
      2. points to a variable that went out of scope.
      Use
      : PSetInvalid
      and our previously defined
      : InvalidReason ir
   3. Unknown; A pointer is assigned something other than the address of
      another =LocalVariable= (e.g., the address of a string.).
      Use
      : PSetUnknown()

*** Derived Class 
    Define the class
    : class PSetEntry extends TPSetEntry
    that implements the =toString()= predicate.

*** Query
    Write a simple query to show where variables go out of scope, 
    : select cfn, "Variable $@ goes out of scope here.", lv, lv.getName()
    Ignore the =TUninitialized= case for now.

*** Solution
    #+INCLUDE: "./src/solutions/Example40.ql" src java

*** First 5 results
    #+INCLUDE: "./tests/solutions/Example40/Example40.expected" :lines "-6"’


    

** Exercise 5.0
   Add the =getLocation()= predicates to
   : class InvalidReason
   so the results show a location.
*** Solution
    #+INCLUDE: "./src/solutions/Example50.ql" src java

*** First 5 results
    #+INCLUDE: "./tests/solutions/Example50/Example50.expected" :lines "-6"’


** Exercise 6.0 -- start pointsToMap
   XX:

   In this predicate we must consider three cases:

   1. The local variable =lv= is assigned a value at location =cfn= that
      defines the /points-to/ set entry =pse=.
   2. The local local variable =lv= is not assigned so we have to propagate
      the /points-to/ set entry from a previous location.
   3. The local variable =lv= is not assigned, but points to a variable
      that went out of scope at location =cfn= so we need to invalid the
      entry for that variable.

   Start on the predicate
   : pointsToMap
   to handle the first two cases, using helper predicates
   : isPointsToEntryDefined
   and
   : getADefinedPointsToEntry(location, lv)
      
*** Solution
    #+INCLUDE: "./src/solutions/Example60.ql" src java

*** First 5 results
    #+INCLUDE: "./tests/solutions/Example60/Example60.expected" :lines "-6"’


** Exercise 7.0 -- cases for getADefinedPointsToEntry
   XX:
   #+BEGIN_SRC text
     // p = &other;

     // p = otherPointer

     // Other cases => unknown
   #+END_SRC

*** Solution
    #+INCLUDE: "./src/solutions/Example70.ql" src java

*** First 5 results
    #+INCLUDE: "./tests/solutions/Example70/Example70.expected" :lines "-6"’


** Exercise 8.0 -- continue pointsToMap   
   XX:

   Check if the points-to set for lv at location contains a PSetVar(otherVariable)
   to determine if otherVariable is still in scope.
   1. If it is not in scope, then replace that entry with invalid/out of scope. 
   2. If it is in scope, then keep the entry as is.

*** Solution
    #+INCLUDE: "./src/solutions/Example80.ql" src java

*** First 5 results
    #+INCLUDE: "./tests/solutions/Example80/Example80.expected" :lines "-6"’

** Exercise 9.0 
   XX:

   Examine pointsToMap results and summarize

** Exercise 2
   :PROPERTIES:
   :CUSTOM_ID: exercise-2
   :END:
   With the /points-to/ set entries modeled we can start to implement parts
   of our /points-to/ set that will associate /points-to/ set entries to
   local variables at a program location. That map will be implemented by
   the predicate =pointsToMap=.

   The following snippet shows the skeleton of that predicate.

   #+begin_src ql
predicate pointsToMap(ControlFlowNode cfn, LocalVariable lv, PSEntry pse) {
}
   #+end_src

   In this predicate we must consider three cases:

   1. The local variable =lv= is assigned a value at location =cfn= that
      defines the /points-to/ set entry =pse=.
   2. The local local variable =lv= is not assigned so we have to propagate
      the /points-to/ set entry from a previous location.
   3. The local variable =lv= is not assigned, but points to a variable
      that went out of scope at location =cfn= so we need to invalid the
      entry for that variable.

   In this exercise we are going to implement the first case by
   implementing the two predicates =isPSetReassigned= and
   =getAnAssignedPSetEntry=.

   - The predicate =isPSetReassigned= should hold if a new /points-to/
     entry should be assigned at that location. This happens when:
     - A local variable is declared and is uninitialized.
     - A local variable is assigned a value.
   - The predicate =getAnAssignedPSEntry= should relate a program location
     and variable to a /points-to/ entry.

   The following snippet provides the skeleton that needs to be completed.

   #+begin_src ql
predicate pointsToMap(ControlFlowNode cfn, LocalVariable lv, PSEntry pse) {
    if isPSetReassigned(cfn, lv)
    then pse = getAnAssignedPSetEntry(cfn, lv)
    else
        ...
}

predicate isPSetReassigned(ControlFlowNode cfn, LocalVariable lv) {
    
}

PSEntry getAnAssignedPSetEntry(ControlFlowNode cfn, LocalVariable lv) {
    
}
   #+end_src

*** Hints
    :PROPERTIES:
    :CUSTOM_ID: hints
    :END:
    1. The class =DeclStmt= models a declaration statement and the predicate
       =getADeclaration= relates what is declared (e.g., a =Variable=)
    2. For a =Variable= we can get the =Expr= that represent the value that
       is assigned to the variable with the predicate =getAnAssignedValue=.
    3. The =AddressOfExpr= models address taken of operation that when
       assigned to a variable can be used to determine if one variable
       points-to another variable.

*** Solution
    :PROPERTIES:
    :CUSTOM_ID: solution-1
    :END:
    The local variable =lv= gets assigned a /points-to/ entry when it is
    declared or assigned a value.

    #+begin_src ql
predicate isPSetReassigned(ControlFlowNode cfn, LocalVariable lv) {
  exists(DeclStmt ds |
    cfn = ds and
    ds.getADeclaration() = lv and
    lv.getType() instanceof PointerType
  )
  or
  cfn = lv.getAnAssignedValue()
}

PSEntry getAnAssignedPSetEntry(ControlFlowNode cfn, LocalVariable lv) {
  exists(DeclStmt ds |
    cfn = ds and
    ds.getADeclaration() = lv
  |
    lv.getType() instanceof PointerType and
    result = PSetInvalid(TUninitialized(ds, lv))
  )
  or
  exists(Expr assign |
    assign = lv.getAnAssignedValue() and
    cfn = assign
  |
    exists(LocalVariable v | v = assign.(AddressOfExpr).getOperand().(VariableAccess).getTarget() |
      result = PSetVar(v)
    )
    or
    exists(VariableAccess va |
      va = assign and
      va.getTarget().(LocalScopeVariable).getType() instanceof PointerType and
      pointsToMap(assign.getAPredecessor(), va.getTarget(), result)
    )
    or
    not assign instanceof AddressOfExpr and
    not assign instanceof VariableAccess and
    result = PSetUnknown()
  )
}
    #+end_src

** Exercise 3
   :PROPERTIES:
   :CUSTOM_ID: exercise-3
   :END:
   With case 1 of the =pointsToMap= being implemented we are going to
   implement case 2 and 3. For case 2 we need to propagate a /points-to/
   entry from a previous location and for case 3 we need to invalidate a
   /points-to/ entry if the entry at the previous location is a =PSetVar=
   for which the variable goes out of scope at our current location =cfn=.

   Note that we only consider case 2 and case 3 if the variable doesn't go
   out of scope at the current location, otherwise we stop propagation for
   of /points-to/ entries for that variable.

   #+begin_src ql
predicate pointsToMap(ControlFlowNode cfn, LocalVariable lv, PSEntry pse) {
    if isPSetReassigned(cfn, lv)
    then pse = getAnAssignedPSetEntry(cfn, lv)
    else
        exists(ControlFlowNode pred, PSEntry prevPse |
            pred = cfn.getAPredecessor() and
            pointsToMap(pred, lv, prevPse) and
            not goesOutOfScope(lv, cfn)
        |
            // case 2
            or
            // case 3
        )
}
   #+end_src

*** Solution
    :PROPERTIES:
    :CUSTOM_ID: solution-2
    :END:
    #+begin_src ql
predicate pointsToMap(ControlFlowNode cfn, LocalVariable lv, PSetEntry pse) {
  if isPSetReassigned(cfn, lv)
  then pse = getAnAssignedPSetEntry(cfn, lv)
  else
    exists(ControlFlowNode predCfn, PSetEntry prevPse |
      predCfn = cfn.getAPredecessor() and
      pointsToMap(predCfn, lv, prevPse) and
      not goesOutOfScope(lv, cfn)
    |
      pse = prevPse and
      not exists(LocalVariable otherLv |
        prevPse = PSetVar(otherLv) and
        goesOutOfScope(otherLv, cfn)
      )
      or
      exists(LocalVariable otherLv |
        prevPse = PSetVar(otherLv) and
        goesOutOfScope(otherLv, cfn) and
        pse = PSetInvalid(TVariableOutOfScope(otherLv, cfn))
      )
    )
}
    #+end_src

** Exercise 4
   :PROPERTIES:
   :CUSTOM_ID: exercise-4
   :END:
   With the /points-to/ map implemented we can find /uses/ of dangling
   pointers.

   Implement the class =DanglingPointerAccess= that finds uses of dangling
   points.

   #+begin_src ql
class DanglingPointerAccess extends PointerDereferenceExpr {
  DanglingPointerAccess() {
    exists(LocalVariable lv, PSetEntry pse |
      this.getOperand().(VariableAccess).getTarget() = lv and
      ...
    )
  }
}
   #+end_src

*** Solution
    :PROPERTIES:
    :CUSTOM_ID: solution-3
    :END:
    #+begin_src ql
class DanglingPointerAccess extends PointerDereferenceExpr {
  DanglingPointerAccess() {
    exists(LocalVariable lv, PSetEntry pse |
      this.getOperand().(VariableAccess).getTarget() = lv and
      pointsToMap(this, lv, pse) and
      pse = PSetInvalid(TVariableOutOfScope(_, _))
    )
  }
}
    #+end_src

** Full solution
   :PROPERTIES:
   :CUSTOM_ID: full-solution
   :END:
   #+begin_src ql
import cpp

newtype TInvalidReason =
  TUninitialized(DeclStmt ds, LocalVariable lv) { ds.getADeclaration() = lv } or
  TVariableOutOfScope(LocalVariable lv, ControlFlowNode cfn) { goesOutOfScope(lv, cfn) }

class InvalidReason extends TInvalidReason {
  string toString() {
    exists(DeclStmt ds, LocalVariable lv |
      this = TUninitialized(ds, lv) and
      result = "variable " + lv.getName() + " is unitialized."
    )
    or
    exists(LocalVariable lv, ControlFlowNode cfn |
      this = TVariableOutOfScope(lv, cfn) and
      result = "variable " + lv.getName() + " went out of scope."
    )
  }
}

newtype TPSetEntry =
  PSetVar(LocalVariable lv) or
  PSetInvalid(InvalidReason ir) or
  PSetUnknown()

class PSetEntry extends TPSetEntry {
  string toString() {
    exists(LocalVariable lv |
      this = PSetVar(lv) and
      result = "Var(" + lv.toString() + ")"
    )
    or
    this = PSetUnknown() and result = "Unknown"
    or
    exists(InvalidReason ir |
      this = PSetInvalid(ir) and
      result = "Invalid because " + ir.toString()
    )
  }
}

predicate goesOutOfScope(LocalVariable lv, ControlFlowNode cfn) {
  exists(BlockStmt scope |
    scope = lv.getParentScope() and
    if exists(scope.getFollowingStmt()) then scope.getFollowingStmt() = cfn else cfn = scope
  )
}

private predicate isPSetReassigned(ControlFlowNode cfn, LocalVariable lv) {
  exists(DeclStmt ds |
    cfn = ds and
    ds.getADeclaration() = lv and
    lv.getType() instanceof PointerType
  )
  or
  cfn = lv.getAnAssignedValue()
}

private PSetEntry getAnAssignedPSetEntry(ControlFlowNode cfn, LocalVariable lv) {
  exists(DeclStmt ds |
    cfn = ds and
    ds.getADeclaration() = lv
  |
    lv.getType() instanceof PointerType and
    result = PSetInvalid(TUninitialized(ds, lv))
  )
  or
  exists(Expr assign |
    assign = lv.getAnAssignedValue() and
    cfn = assign
  |
    exists(LocalVariable otherLv |
      otherLv = assign.(AddressOfExpr).getOperand().(VariableAccess).getTarget()
    |
      result = PSetVar(otherLv)
    )
    or
    exists(VariableAccess va |
      va = assign and
      va.getTarget().(LocalScopeVariable).getType() instanceof PointerType and
      pointsToMap(assign.getAPredecessor(), va.getTarget(), result)
    )
    or
    not assign instanceof AddressOfExpr and
    not assign instanceof VariableAccess and
    result = PSetUnknown()
  )
}

predicate pointsToMap(ControlFlowNode cfn, LocalVariable lv, PSetEntry pse) {
  if isPSetReassigned(cfn, lv)
  then pse = getAnAssignedPSetEntry(cfn, lv)
  else
    exists(ControlFlowNode predCfn, PSetEntry prevPse |
      predCfn = cfn.getAPredecessor() and
      pointsToMap(predCfn, lv, prevPse) and
      not goesOutOfScope(lv, cfn)
    |
      pse = prevPse and
      not exists(LocalVariable otherLv |
        prevPse = PSetVar(otherLv) and
        goesOutOfScope(otherLv, cfn)
      )
      or
      exists(LocalVariable otherLv |
        prevPse = PSetVar(otherLv) and
        goesOutOfScope(otherLv, cfn) and
        pse = PSetInvalid(TVariableOutOfScope(otherLv, cfn))
      )
    )
}

class DanglingPointerAccess extends PointerDereferenceExpr {
  DanglingPointerAccess() {
    exists(LocalVariable lv |
      this.getOperand().(VariableAccess).getTarget() = lv and
      pointsToMap(this, lv, PSetInvalid(TVariableOutOfScope(_, _)))
    )
  }
}

from DanglingPointerAccess dpa
select dpa
   #+end_src

